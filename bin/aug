#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
#
require 'rainbow'
require 'optparse'


AUGER_DIR = File.dirname(File.dirname(__FILE__))
AUGER_LIB = File.join(AUGER_DIR, 'lib')
load "#{AUGER_LIB}/auger.rb"

## use AUGER_DIR/cfg unless AUGER_CFG is set
if ENV['AUGER_CFG'] == nil
  AUGER_CFG = File.join(AUGER_DIR, 'cfg').split
else
  AUGER_CFG = ENV['AUGER_CFG'].split(':')
end

## load plugins
Dir["#{AUGER_DIR}/lib/plugins/*.rb"].each {|file| require file }

## relative path to libs
$LOAD_PATH.unshift(AUGER_LIB) unless $LOAD_PATH.include?(AUGER_LIB)


## set opts
options = {}
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: aug [-h|--help] [-l|--list] cfg"

  if ARGV[0] == nil
    puts opts.banner.color(:yellow)
    exit
  end

  opts.on('-l', '--list', 'List available configs and exit.') do
    AUGER_CFG.each do |c|
      puts Dir["#{c}/*.rb"].map {|file| File.basename(file).sub(/\.rb$/, '')}
    end
    exit
  end

  opts.on('-h', '--help', 'Display help') do
    puts opts
    exit
  end

  opts.on('-v', '--version', 'Display version and exit.') do
    puts "auger, version #{Auger::VERSION}"
    exit
  end
end
optparse.parse!

## cfg file can be e.g. 'imagine' or relative path
if File.exists?(ARGV[0])
  cfg = ARGV[0]
else
  AUGER_CFG.each do |path|
    if File.exists?("#{path}/#{ARGV[0]}.rb")
      cfg = "#{path}/#{ARGV[0]}.rb"
    end
  end
end

## pretty ascii output for different result outcomes
def format_outcome(outcome)
  case outcome
  when TrueClass then
    "\u2713".color(:green)
  when MatchData then # boolean if no captures, otherwise list captures
    (outcome.captures.empty? ? "\u2713" : outcome.captures.join(' '))
      .color(:green)
  when FalseClass then
    "\u2717".color(:red)
  when NilClass then
    "nil".color(:red)
  when Exception then
    "#{outcome.class}: #{outcome.to_s}".color(:magenta)
  else
    outcome.to_s.color(:green)
  end
end

Auger::Config.load(cfg).projects.each do |p|

  threads = Hash.new { |h,k| h[k] = [] }

  ## run tests
  p.connections.each do |c|
    p.servers(c.roles).map do |server|
      threads[server.name] << Thread.new do
        c.do_requests(server)
        c.requests.map { |request| request.do_tests }
      end
    end
  end

  ## width of test name column
  max_test_length = 
    p.connections.map{|c| c.requests.map{|r| r.tests.map{|t| t.name.length}}}.flatten.max

  ## print results
  threads.keys.each do |server|
    puts "[#{server.color(:cyan)}]"
    threads[server].each do |thread| 
      results = thread.value    # this waits on thread
      results.flatten.each do |result|
        output = format_outcome(result.outcome)
        puts "  %+#{max_test_length}s  %-30s" % [result.test.name, output]
      end
    end
  end

end
