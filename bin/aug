#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'rainbow'
require 'optparse'

AUGER_DIR = File.dirname(File.dirname(__FILE__))
AUGER_LIB = File.join(AUGER_DIR, 'lib')
AUGER_CFG = (ENV['AUGER_CFG'] || File.join(AUGER_DIR, 'cfg')).split(File::PATH_SEPARATOR)

## relative path to libs (in case not installed as a gem)
$LOAD_PATH.unshift(AUGER_LIB) unless $LOAD_PATH.include?(AUGER_LIB)
require 'auger'

## set opts
options = {}
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: aug [-h|--help] [-l|--list] [-v|--version] cfg"

  if ARGV[0] == nil
    puts opts.banner.color(:yellow)
    exit
  end

  opts.on('-l', '--list', 'List available configs and exit.') do
    list = AUGER_CFG.map do |dir| 
      Dir["#{dir}/*.rb"].map{ |file| File.basename(file).sub(/\.rb$/, '') } 
    end
    puts list.flatten.sort
    exit
  end

  opts.on('-h', '--help', 'Display help') do
    puts opts
    exit
  end

  opts.on('-s', '--server REGEX', 'Limit to server names matching regex.') do |s|
    options[:server] = s
  end

  opts.on('-t', '--time', 'Show request times.') do |t|
    options[:time] = true
  end

  opts.on('-v', '--version', 'Display version and exit.') do
    puts Auger::VERSION.color(:green)
    exit
  end
end
optparse.parse!

## cfg file can be e.g. 'imagine' or relative path
cfg = 
  if File.exists?(ARGV[0])
    ARGV[0]
  elsif path = AUGER_CFG.find { |path| File.exists?("#{path}/#{ARGV[0]}.rb") }
    [path, "#{ARGV[0]}.rb"].join(File::SEPARATOR)
  else
    raise ArgumentError, "config #{ARGV[0]} not found"
  end

## pretty-print Result object
module Auger
  class Result

    def format
      output = 
        case self.outcome
        when TrueClass  then "\u2713"
        when MatchData  then outcome.captures.empty? ? "\u2713" : outcome.captures.join(' ')
        when FalseClass then "\u2717"
        when NilClass   then "nil"
        when Exception  then "#{outcome.class}: #{outcome.to_s}"
        else                 outcome.to_s
        end

      color =
        case self.status
        when FalseClass, NilClass then :red
        when Exception            then :magenta
        when Status               then
          case self.status.value
            when :ok        then :green
            when :warn      then :yellow
            when :exception then :magenta
          else                   :red
          end
        else                           :green
        end
    
      return output.color(color)
    end
  end
end

Auger::Config.load(cfg).projects.each do |project|

  threads = Hash.new { |h,k| h[k] = [] }

  ## run tests
  project.connections.each do |connection|
    servers = project.servers(connection.roles)
    servers.select! { |server| server.name.match(options[:server]) } if options[:server]
    servers.map do |server|
      threads[server.name] << Thread.new do
        conn = connection.do_open(server)
        connection.requests.map do |request|
          response, time = request.do_run(conn)
          request.tests.map do |test|
            result = test.run(response)
            result.time = time
            result
          end
        end
      end
    end
  end

  ## width of test name column
  max_test_length = 
    project.connections.map{|c| c.requests.map{|r| r.tests.map{|t| t.name.length}}}.flatten.max

  ## print results
  threads.keys.each do |server|
    puts "[#{server.color(:cyan)}]"
    threads[server].each do |thread| 
      results = thread.value    # this waits on thread
      results.flatten.each do |result|
        output = "  %+#{max_test_length}s  %-30s" % [result.test.name, result.format]
        output << "[#{result.time}]".color(:blue) if options[:time]
        puts output
      end
    end
  end

end
