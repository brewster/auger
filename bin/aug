#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

AUGER_DIR = File.dirname(File.dirname(__FILE__))
AUGER_LIB = File.join(AUGER_DIR, 'lib')
AUGER_CFG = ENV['AUGER_CFG'] || File.join(AUGER_DIR, 'cfg')

## relative path to libs
$LOAD_PATH.unshift(AUGER_LIB) unless $LOAD_PATH.include?(AUGER_LIB)

require "rainbow"
require "optparse"
require "auger"

options = {}
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: aug [-h|--help] [-f|--fqdn] [-l|--list] cfg"

  if ARGV[0] == nil
    puts opts.banner.color(:yellow)
    exit
  end

  opts.on('-f', '--fqdn', 'Test FQDN/VIPs instead of hosts.') { options[:fqdn] = true }
  opts.on('-l', '--list', 'List available configs and exit.') do
    puts Dir["#{AUGER_CFG}/*.rb"].map {|file| File.basename(file).sub(/\.rb$/, '')}
    exit
  end
  opts.on('-h', '--help', 'Display help') do
    puts opts
    exit
  end
end
optparse.parse!


## load plugins
Dir["#{AUGER_DIR}/lib/plugins/*.rb"].each {|file| require file }

## cfg file can be e.g. 'imagine' or relative path
cfg = File.exists?(ARGV[0]) ? ARGV[0] : "#{AUGER_CFG}/#{ARGV[0]}.rb"

Auger::Config.load(cfg).projects.each do |p|

  ## max length of test names for formatting output
  max_test_length = 
    p.connections.map{|c| c.requests.map{|r| r.tests.map{|t| t.name.length}}}.flatten.max

  ## -f option uses fqdn
  hostlist = options[:fqdn] ? p.fqdns : p.hosts
  
  hostlist.each do |host|
    puts "[#{host.color(:cyan)}]"

    p.connections.each do |c|

      begin
        conn = c.open(host)
        c.requests.each do |request|
          request.response = request.run(conn) rescue $!
        end
        c.close conn
      rescue => e
        c.requests.each do |request|
          request.response = e  # response can be an Exception if we caught one
        end
      end

      ## array of test results
      results = c.requests.map do |request|

        ## callback to be run before tests
        request.before_tests_proc.call(request.response) if request.before_tests_proc

        ## run tests
        request.tests.map do |test|
          outcome =
            if request.response.is_a? Exception # if request failed, just report that
              request.response
            else
              test.run(request.response)
            end
          Auger::Result.new(test, outcome)
        end
      end
      
      ## print results
      results.flatten.each do |result|

        ## format test outcome based on class
        output = case result.outcome
                 when TrueClass then
                   "\u2713".color(:green)
                 when MatchData then
                   (result.outcome.captures.empty? ? "\u2713" : result.outcome.captures.join(' '))
                     .color(:green)
                 when FalseClass then
                   "\u2717".color(:red)
                 when NilClass then
                   "nil".color(:red)
                 when Exception then
                   "#{result.outcome.class}: #{result.outcome.to_s}".color(:magenta)
                 else
                   result.outcome.to_s.color(:green)
                 end

        puts "  %+#{max_test_length}s  %-30s" % [result.test.name, output]
      end

    end

  end

end
